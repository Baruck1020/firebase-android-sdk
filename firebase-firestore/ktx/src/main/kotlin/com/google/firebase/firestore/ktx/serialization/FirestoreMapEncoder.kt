// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.firebase.firestore.ktx.serialization

import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.JavaDocumentReference
import com.google.firebase.firestore.encoding.FirestoreAbstractEncoder
import com.google.firebase.firestore.JavaGeoPoint
import com.google.firebase.firestore.ktx.annotations.KDocumentId
import com.google.firebase.firestore.ktx.annotations.KServerTimestamp
import com.google.firebase.firestore.ktx.serializers.FirestoreSerializersModule
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.SerialKind
import kotlinx.serialization.descriptors.StructureKind
import kotlinx.serialization.descriptors.elementDescriptors
import kotlinx.serialization.encoding.AbstractEncoder
import kotlinx.serialization.encoding.CompositeEncoder
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.serializer

/**
 * The entry point of Firestore Kotlin Serialization Process. It encodes a custom @Serializable
 * Kotlin object into a nested map of primitives. SDK users don’t need to directly interact with
 * [FirestoreMapEncoder].
 *
 * <p>For a custom @Serializable object, at compile time, a serializer will be generated by the
 * Kotlin serialization compiler plugin (or a custom serializer can be manually passed in). The
 * structure information of the custom @Serializable object will be recorded inside of the
 * serializer’s descriptor (i.e. the name/type of each property to be encoded, the annotation on
 * each property).
 *
 * <p>Based on the descriptor’s information, during the encoding process, a nested map will be
 * generated. Each property which has its own structure (i.e. a nested custom object, a nested list)
 * will be encoded as an embedded map nested inside. At the end, the nested map at depth == 1 will
 * be returned as the nested map representing the entire custom @Serializable object.
 *
 * @param map the nested map that records the encoded result of the original @Serializable object.
 * @param depth the current encoding depth inside of the nested map.
 * @param descriptor a [SerialDescriptor] of the custom object.
 */
class FirestoreMapEncoder(
    private val map: MutableMap<Int, MutableMap<String, Any?>> = mutableMapOf(),
    private var depth: Int = 0,
    private val descriptor: SerialDescriptor? = null
) : AbstractEncoder(), FirestoreAbstractEncoder {

    companion object {
        private const val ROOT_LEVEL: Int = 1
        private const val MAX_DEPTH: Int = 500
    }

    private inner class CurrentElementToEncode(val elementIndex: Int = 0) {
        val elementEncodeKey: String by lazy {
            try {
                descriptor?.getElementName(elementIndex) as String
            } catch (err: Exception) {
                throw IndexOutOfBoundsException(
                    "The key of the element to be encoded can not be null"
                )
            }
        }
        val elementKind: SerialKind? = descriptor?.getElementKindOrNull(elementIndex)
        val elementSerialName: String? = descriptor?.getElementSerialNameOrNull(elementIndex)
        val elementAnnotations: List<Annotation>? =
            descriptor?.elementAnnotationsOrNull(elementIndex)
    }

    /**
     * Return a list of annotations of the child element at a given index [elementIndex]; In case of
     * [IndexOutOfBoundsException], and [IllegalArgumentException], null will be returned. Other
     * types of exception will be raised.
     */
    private fun SerialDescriptor.elementAnnotationsOrNull(elementIndex: Int): List<Annotation>? =
        try {
            getElementAnnotations(elementIndex)
        } catch (err: Exception) {
            when (err) {
                is IndexOutOfBoundsException,
                is IllegalArgumentException -> null
                else -> throw err
            }
        }

    private fun SerialDescriptor.getElementKindOrNull(elementIndex: Int): SerialKind? =
        elementDescriptors?.toList()?.getOrNull(elementIndex)?.kind

    private fun SerialDescriptor.getElementSerialNameOrNull(elementIndex: Int): String? =
        elementDescriptors?.toList()?.getOrNull(elementIndex)?.serialName

    private var theBeginOfEncodingProcess: Boolean = true

    private var currentElement = CurrentElementToEncode()

    init {
        if (depth == ROOT_LEVEL) map[ROOT_LEVEL] = mutableMapOf()
        if (depth == MAX_DEPTH) {
            throw IllegalArgumentException(
                "Exceeded maximum depth of $MAX_DEPTH, which likely indicates there's an object cycle"
            )
        }
    }

    /** Returns the final encoded nested map. */
    fun serializedResult() = map.getValue(ROOT_LEVEL)

    /** Get the field name of an enum via index, and encode it to the nested map. */
    override fun encodeEnum(enumDescriptor: SerialDescriptor, index: Int) =
        encodeValue(enumDescriptor.getElementName(index))

    private fun generateCurrentElementForEncoding() {
        if (theBeginOfEncodingProcess) {
            theBeginOfEncodingProcess = false
        } else {
            currentElement = CurrentElementToEncode(currentElement.elementIndex + 1)
        }
    }


    /**
     * Register serializers for Firestore native data types, DocumentId, Timestamp, Date, and
     * GeoPoint, so that these registered serializers can be used at run-time to serialize the
     * fields with @Contextual annotations
     */
    override val serializersModule: SerializersModule = FirestoreSerializersModule

    /** Encode the native Firestore datatype objects: DocumentId, Timestamp, Date, and GeoPoint. */
    fun <T> encodeFirestoreNativeDataType(value: T) {
        println(">".repeat(80))
        generateCurrentElementForEncoding()
        validateKServerTimestampPresentOrThrow()
        when {
            validateKDocumentIdPresentOrThrow() -> {} // KDocumentId on DocumentReference, then
            // ignore
            else -> map.getValue(depth).put(currentElement.elementEncodeKey, value)
        }
    }


    override fun encodeGeoPoint(value: JavaGeoPoint) {
        generateCurrentElementForEncoding()
        map.getValue(depth).put(currentElement.elementEncodeKey, value)
    }

    override fun encodeDocumentReference(value: JavaDocumentReference){
        generateCurrentElementForEncoding()
        map.getValue(depth).put(currentElement.elementEncodeKey, value)
    }

    override fun encodeNull() {
        generateCurrentElementForEncoding()
        when {
            validateKDocumentIdPresentOrThrow() -> {} // KDocumentId on String?, DocumentReference?,
            // then ignore
            validateKServerTimestampPresentOrThrow() ->
                map.getValue(depth)
                    .put(
                        currentElement.elementEncodeKey,
                        FieldValue.serverTimestamp()
                    ) // KServerTimestamp on Timestamp? = null, then replace with FieldValue
            else -> map.getValue(depth).put(currentElement.elementEncodeKey, null)
        }
    }

    override fun encodeValue(value: Any) {
        println("=".repeat(50))
        println(value)
        generateCurrentElementForEncoding()
        when {
            validateKDocumentIdPresentOrThrow() -> {} // KDocumentId on String, then ignore
            validateKServerTimestampPresentOrThrow() -> {} // KServerTimestamp can not on Primitives
            else -> map.getValue(depth).put(currentElement.elementEncodeKey, value)
        }
    }

    override fun endStructure(descriptor: SerialDescriptor) {
        if (depth != ROOT_LEVEL) {
            map.remove(depth--)
        }
    }

    /**
     * Recursively build the nested map when an encoded property has its own structure (i.e. a
     * nested custom @Serializable object, a nested list)
     *
     * @param descriptor the [SerialDescriptor] of the @Serializable object at current depth.
     * @return a CompositeEncoder either to be a [FirestoreMapEncoder] or a [FirestoreListEncoder].
     */
    override fun beginStructure(descriptor: SerialDescriptor): CompositeEncoder {
        throwOnInvalidKDocumentIdAndKServerTimestampAnnotation()
        if (depth == 0) {
            return FirestoreMapEncoder(map, depth + 1, descriptor)
        }
        println(">>>>>>>>>>>>> ${descriptor.kind} >>>>>>>>>>> ${descriptor.serialName}")
        when (descriptor.kind) {
            StructureKind.CLASS -> {
                val nextDepth = depth + 1
                generateCurrentElementForEncoding()
                println("<<<<<<<<<< key is ${currentElement.elementEncodeKey} ") // field name
                println("<<<<<<<<<< serialName is ${currentElement.elementSerialName} ") // descriptor's GeoPointSerialName
                // if I catched this, I should delegated to the FIrestore method
                map[nextDepth] = mutableMapOf()
                map.getValue(depth).put(currentElement.elementEncodeKey, map[nextDepth])
                return FirestoreMapEncoder(map, nextDepth, descriptor)
            }
            StructureKind.LIST -> {
                val emptyList = mutableListOf<Any?>()
                generateCurrentElementForEncoding()
                map.getValue(depth).put(currentElement.elementEncodeKey, emptyList)
                return FirestoreListEncoder(map, depth, emptyList)
            }
            else -> {
                throw IllegalArgumentException(
                    "Incorrect format of nested object provided: <$descriptor.kind>"
                )
            }
        }
    }

    /**
     * Returns true is @[KDocumentId] is applied to a property of a type String or
     * DocumentReference; Otherwise, a runtime exception will be thrown.
     */
    private fun kDocumentIdAppliedOnValidProperty(): Boolean {
        if (
            currentElement.elementKind == PrimitiveKind.STRING ||
                (currentElement.elementSerialName as String).contains("<DocumentReference>")
        ) {
            return true
        } else {
            throw IllegalArgumentException(
                "Field is annotated with @KDocumentId but is class $currentElement.elementKind ( with serial name ${currentElement.elementSerialName} ) instead of String or DocumentReference."
            )
        }
    }

    /**
     * Returns true if @[KDocumentId] is present and applied on a property of String or
     * DocumentReference; Returns false if @[KDocumentId] is absent; Throws runtime exception if @
     * [KDocumentId] is present but applied on a property of an invalid type.
     */
    private fun validateKDocumentIdPresentOrThrow(): Boolean {
        val kDocumentIdPresent = currentElement.elementAnnotations?.any { it is KDocumentId }
        return if (kDocumentIdPresent == true) {
            kDocumentIdAppliedOnValidProperty()
        } else {
            false
        }
    }

    /**
     * Returns true is @[KServerTimestamp] is applied to a property of a type Date or Timestamp;
     * Otherwise, a runtime exception will be thrown.
     */
    private fun kServerTimestampAppliedOnValidProperty(): Boolean {
        if (
            (currentElement.elementSerialName as String).run {
                contains("<Timestamp>") || contains("<Date>")
            }
        ) {
            return true
        } else {
            throw IllegalArgumentException(
                "Field is annotated with @KServerTimestamp but is class $currentElement.elementKind ( with serial name ${currentElement.elementSerialName} ) instead of Date or Timestamp."
            )
        }
    }

    /**
     * Returns true if @[KServerTimestamp] is present and applied on a property of Date or
     * Timestamp; Returns false if @[KServerTimestamp] is absent; Throws runtime exception if @
     * [KServerTimestamp] is present but applied on a property of an invalid type.
     */
    private fun validateKServerTimestampPresentOrThrow(): Boolean {
        val kServerTimestampPresent =
            currentElement.elementAnnotations?.any { it is KServerTimestamp }
        return if (kServerTimestampPresent == true) {
            kServerTimestampAppliedOnValidProperty()
        } else {
            false
        }
    }

    /**
     * Throw runtime exception if [KDocumentId] or [KServerTimestamp] is applied on a property of an
     * invalid type
     */
    private fun throwOnInvalidKDocumentIdAndKServerTimestampAnnotation() {
        validateKDocumentIdPresentOrThrow()
        validateKServerTimestampPresentOrThrow()
    }
}

/**
 * The entry point of encoding a List type property during Firestore Kotlin Serialization Process.
 * It encodes a List type property inside of a custom @Serializable Kotlin object, converts it into
 * a list of primitives or a list of nested maps. SDK users don’t need to directly interact with
 * [FirestoreListEncoder].
 *
 * @param map the nested map that records the encoded result of the original @Serializable object.
 * @param depth the current encoding depth inside of the nested map.
 * @param encodedList the encoded result of the current nested list.
 */
class FirestoreListEncoder(
    private val map: MutableMap<Int, MutableMap<String, Any?>> = mutableMapOf(),
    private val depth: Int = 0,
    private val encodedList: MutableList<Any?> = mutableListOf()
) : AbstractEncoder() {

    /**
     * Register serializers for Firestore native data types, DocumentId, Timestamp, and GeoPoint, so
     * that these registered serializers can be used at run-time to serialize the fields with
     * @Contextual annotations
     */
    override val serializersModule: SerializersModule = FirestoreSerializersModule

    /** Encode the native Firestore datatype objects: DocumentId, Timestamp, and GeoPoint. */
    fun <T> encodeFirestoreNativeDataType(value: T) {
        encodedList.add(value)
        elementIndex++
    }

    private var elementIndex: Int = 0

    override fun encodeValue(value: Any) {
        encodedList.add(value)
        elementIndex++
    }

    override fun encodeNull() {
        encodedList.add(null)
        elementIndex++
    }

    /**
     * Recursively build the nested map when the element inside of the nested list has its own
     * structure (i.e. a list of nested custom @Serializable object)
     *
     * <p>Note: Firestore does not support read/write high dimensional nested lists; therefore,
     * list's content must be either primitive type elements or @Serializable objects.
     * IllegalArgumentException will be thrown if list contains elements of other types.
     *
     * @param descriptor the [SerialDescriptor] of the @Serializable object at current depth.
     * @return a [FirestoreMapEncoder].
     */
    override fun beginStructure(descriptor: SerialDescriptor): CompositeEncoder {
        when (descriptor.kind) {
            StructureKind.CLASS -> {
                val nextDepth = depth + 1
                map[nextDepth] = mutableMapOf()
                encodedList.add(map[nextDepth])
                return FirestoreMapEncoder(map, nextDepth, descriptor)
            }
            else -> {
                throw IllegalArgumentException(
                    "Incorrect format of nested object provided: <$descriptor.kind>"
                )
            }
        }
    }
}

/**
 * Returns the encoded contents of a @Serializable object converted to a nested map.
 *
 * @param serializer The SerializationStrategy of the @Serializable Kotlin object.
 * @param value The @Serializable Kotlin object.
 * @return The encoded nested map of a @Serializable Kotlin object.
 */
fun <T> encodeToMap(serializer: SerializationStrategy<T>, value: T): MutableMap<String, Any?> {
    val encoder = FirestoreMapEncoder()
    encoder.encodeSerializableValue(serializer, value)
    return encoder.serializedResult()
}

/**
 * Returns the encoded contents of a @Serializable object converted to a nested map.
 *
 * @param value The @Serializable Kotlin object.
 * @return The encoded nested map of a @Serializable Kotlin object.
 */
inline fun <reified T> encodeToMap(value: T): MutableMap<String, Any?> =
    encodeToMap(serializer(), value)
